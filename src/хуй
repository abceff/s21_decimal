#include "s21_decimal.h"

// Арифметические операторы
// int s21_add(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
//     // code
// }

// int s21_sub(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
//     // code
// }

// int s21_mul(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
//     // code
// }

// int s21_div(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
//     // code
// }

// int s21_mod(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
//     // code
// }

// Операторы сравнение
int s21_is_less(s21_decimal value_1, s21_decimal value_2) {
    int res = -1;
    int whichisNegative = isNegative(&value_1, &value_2);

    if (whichisNegative == 1) {
        res = 0;
    }
    if (whichisNegative == -1) {
        res = 1;
    }
    convertorScale(&value_1, &value_2);
    if (s21_is_equal(value_1, value_2) == 1) {
        res = 0;
    }
    for (int i = 95; i >= 0 && res == -1; i--) {
        int bit_value_1 = getBit(value_1, i);
        int bit_value_2 = getBit(value_2, i);
        if (bit_value_1 == 1 && bit_value_2 == 0) {
            res = 0;
        }
        if (bit_value_2 == 1 && bit_value_1 == 0) {
            res = 1;
        }
        if (res != -1) {
            if (getSign(value_1) == 1 && getSign(value_2) == 1) {
                res = !res;
            }
        }
    }
    return res;
}

int s21_is_less_or_equal(s21_decimal value_1, s21_decimal value_2) {
    return s21_is_equal(value_1, value_2) || s21_is_less(value_1, value_2);
}

int s21_is_greater(s21_decimal value_1, s21_decimal value_2) {
    return s21_is_less(value_2, value_1);
}

int s21_is_greater_or_equal(s21_decimal value_1, s21_decimal value_2) {
    return s21_is_equal(value_1, value_2) || s21_is_greater(value_1, value_2);
}

int s21_is_equal(s21_decimal value_1, s21_decimal value_2) {
    int res = -1;
    int whichisNegative = isNegative(&value_1, &value_2);
    if (whichisNegative != 0) {
        res = 0;
    }
    convertorScale(&value_1, &value_2);
    for (int i = 95; i >= 0 && res == -1; i--) {
        int bit_value_1 = getBit(value_1, i);
        int bit_value_2 = getBit(value_2, i);
        if (bit_value_1 != bit_value_2) {
            res = 0;
        }
    }
    return (res != 0) ? 1 : 0;
}

int s21_is_not_equal(s21_decimal value_1, s21_decimal value_2) {
    return !s21_is_equal(value_1, value_2);
}

// Преобразователи
int s21_from_int_to_decimal(int src, s21_decimal *dst) {
    int status = 0;
    if (dst) {
        initDecimal(dst);
        if (src >= 0) {
            dst->bits[0] = src;
        } else {
            setSign(dst, 1);
            dst->bits[0] = ~src + 1;
        }
    } else {
        status = 1;
    }
    return status;
}

// int s21_from_float_to_decimal(float src, s21_decimal *dst) {

// }

int s21_from_decimal_to_int(s21_decimal src, int *dst) {
    int status = 0;
    if (dst == 0 || positionFirstNum(src) > 31 || src.bits[0] > 0x7FFFFFFF) {
        status = 1;
    } else {
        *dst = (int)src.bits[0];
        char sc = getScale(src);
        while (sc--) *dst /= 10;
        if (getSign(src) == 1) {
            *dst *= -1;
        }
    }
    return status;
}

// int s21_from_decimal_to_float(s21_decimal src, float *dst) {
//     // code
// }

// Другие функции
int s21_floor(s21_decimal value, s21_decimal *result) {
    if (getSign(value) == 1) {
        int Scale = getScale(value);
        shiftScaleRigth(&value, Scale);
        copyDecimalToDecimal(value, result);
    } else {
        generetionTruncFloor(value, result);
    }

    return 0;
}

int s21_round(s21_decimal value, s21_decimal *result) {
    int Scale = getScale(value);
    shiftScaleRigth(&value, Scale);
    copyDecimalToDecimal(value, result);
    return 0;
}

int s21_truncate(s21_decimal value, s21_decimal *result) {
    generetionTruncFloor(value, result);
    return 0;
}

int s21_negate(s21_decimal value, s21_decimal *result) {
    setScale(&value, 1);
    copyDecimalToDecimal(value, result);
    return 0;
}

// Дополнительные функции
void setBit(s21_decimal *d, int i, int v) {
    unsigned int mask = 1u << (i % 32);
    if (v == 1) {
        d->bits[i / 32] |= mask;
    }
    if (v == 0) {
        d->bits[i / 32] &= ~mask;
    }
}

int getBit(s21_decimal d, int i) {
    unsigned int mask = 1u << (i % 32);
    return ((d.bits[i / 32] & mask) != 0);
}

int getSign(s21_decimal d) { return d.bits[3] >> 31; }

void setSign(s21_decimal *d, int i) {
    unsigned int mask = 1u << 31;
    if (i == 1) {
        d->bits[3] |= mask;
    }
    if (i == 0) {
        d->bits[3] &= ~mask;
    }
}

int getScale(s21_decimal d) {
    setSign(&d, 0);
    d.bits[3] >>= 16;
    return d.bits[3];
}

void setScale(s21_decimal *d, int i) {
    if (i >= 0 && i <= 28) {
        int cleanMask = ~(0xFF << 16);
        d->bits[3] &= cleanMask;
        int mask = i << 16;
        d->bits[3] |= mask;
    }
}

int isNegative(s21_decimal *value_1, s21_decimal *value_2) {
    int res = 0;
    int sign_value_1 = getSign(*value_1);
    int sign_value_2 = getSign(*value_2);
    if (sign_value_1 == 0 && sign_value_2 == 1) {
        res = 1;
    }
    if (sign_value_1 == 1 && sign_value_2 == 0) {
        res = -1;
    }
    return res;
}

int shiftScaleLeft(s21_decimal *d, int scale) {
    int status = 0;
    int origin_sign = getScale(*d);
    for (int i = 0; i < scale; i++) {
        s21_decimal tmp1 = *d;
        s21_decimal tmp2 = *d;
        if (shiftDecimalLeft(&tmp1, 3) == 1) {
            status = 1;
            break;
        }
        if (shiftDecimalLeft(&tmp2, 1) == 1) {
            status = 1;
            break;
        }
        if (sumBits(tmp1, tmp2, d) == 1) {
            status = 1;
            break;
        }
    }
    setScale(d, origin_sign + scale);
    return status;
}

int shiftDecimalLeft(s21_decimal *d, int shift) {
    int status = 0;
    for (int i = 0; i < shift; i++) {
        int bits0 = getBit(*d, 31);
        int bits1 = getBit(*d, 63);
        int bits2 = getBit(*d, 95);
        d->bits[0] <<= 1;
        d->bits[1] <<= 1;
        d->bits[2] <<= 1;
        if (bits0 == 1) {
            setBit(d, 32, 1);
        }
        if (bits1 == 1) {
            setBit(d, 64, 1);
        }
        if (bits2 == 1) {
            status = 1;
            break;
        }
    }
    return status;
}

int shiftScaleRigth(s21_decimal *d, int shiftScale) {
    unsigned int minuend;
    s21_decimal resultOfDevide;
    int status = 0;
    for (; shiftScale != 0; shiftScale--) {
        initDecimal(&resultOfDevide);
        int begin = positionFirstNum(*d);

        minuend = 0;
        initMinuend(&minuend, *d, begin);
        int i = 95;
        int check = 0;

        for (int j = begin - 3; j >= 0 && check == 0; j--, i--) {
            if (minuend >= 10u) {
                setBit(&resultOfDevide, i, 1);
                minuend -= 10u;
                minuend <<= 1;
                setBitInt(&minuend, 0, getBit(*d, j - 1));
            } else {
                setBit(&resultOfDevide, i, 0);
                minuend <<= 1;
                if (j != 0) {
                    setBitInt(&minuend, 0, getBit(*d, j - 1));
                }
            }
            if (minuend < 10u && j == 0) {
                check = 1;
            }
        }
        minuend >>= 1;
        initDecimal(d);
        int tmp = 95;
        for (int j = 94 - i; j >= 0; j--, tmp--) {
            setBit(d, j, getBit(resultOfDevide, tmp));
        }
        if (minuend >= 5 && shiftScale == 1) {
            sumWithNumOne(d);
            status = 1;
        }
    }
    return status;
}

void initMinuend(unsigned int *minuend, s21_decimal d, int begin) {
    int i = 3;
    for (int j = 0; i >= 0; j++, i--) {
        setBitInt(minuend, j, getBit(d, begin - i));
    }
}

void sumWithNumOne(s21_decimal *d) {
    int changer = 0;
    s21_decimal value_1 = *d;
    s21_decimal value_2 = {{1, 0, 0, 0}};

    initDecimal(d);
    shiftScaleLeft(&value_2, getScale(value_1));
    for (int i = 0; i < 96; i++) {
        int num_1 = getBit(value_1, i);
        int num_2 = getBit(value_2, i);
        if ((num_1 == 0 && num_2 == 0) || (num_1 == 1 && num_2 == 1))
            setBit(d, i, 0 + changer);
        if ((num_1 == 0 && num_2 == 1) || (num_1 == 1 && num_2 == 0))
            setBit(d, i, 1 - changer);
        if ((num_1 + num_2 + changer) > 1)
            changer = 1;
        else
            changer = 0;
    }
}

void setBitInt(unsigned int *d, int i, int v) {
    unsigned int mask = 1u << i;
    if (v == 1) *d |= mask;
    if (v == 0) *d &= ~mask;
}

int convertorScale(s21_decimal *value_1, s21_decimal *value_2) {
    int Scale1 = getScale(*value_1);
    int Scale2 = getScale(*value_2);
    int difference;
    if (Scale1 > Scale2) {
        difference = Scale1 - Scale2;
        if (shiftScaleLeft(value_2, difference) == 1) {
            Scale2 = getScale(*value_2);
            difference = Scale1 - Scale2;
            shiftScaleRigth(value_1, difference);
            setScale(value_1, Scale2);
        }
    } else {
        difference = Scale2 - Scale1;
        if (shiftScaleLeft(value_1, difference) == 1) {
            Scale1 = getScale(*value_1);
            difference = Scale2 - Scale1;
            shiftScaleRigth(value_2, difference);
            setScale(value_2, Scale1);
        }
    }
    return 0;
}

int sumBits(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
    int changer = 0;
    int status = 0;

    for (int i = 0; i < 96; i++) {
        int num_1 = getBit(value_1, i);
        int num_2 = getBit(value_2, i);
        if ((num_1 == 0 && num_2 == 0) || (num_1 == 1 && num_2 == 1)) {
            setBit(result, i, 0 + changer);
        }
        if ((num_1 == 0 && num_2 == 1) || (num_1 == 1 && num_2 == 0)) {
            setBit(result, i, 1 - changer);
        }
        if ((num_1 + num_2 + changer) > 1) {
            changer = 1;
        } else {
            changer = 0;
        }
        if (i == 95 && changer == 1) {
            status = 1;
        }
    }
    return status;
}

void subBits(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
    int big_value = 0;
    for (int i = 0; i < 96; i++) {
        if ((getBit(value_1, i) == 0 && getBit(value_2, i) == 0) ||
            (getBit(value_1, i) == 1 && getBit(value_2, i) == 1)) {
            setBit(result, i, 0 + big_value);
        }
        if ((getBit(value_1, i) == 0 && getBit(value_2, i) == 1) ||
            (getBit(value_1, i) == 1 && getBit(value_2, i) == 0)) {
            setBit(result, i, 1 - big_value);
        }
        if ((getBit(value_1, i) - getBit(value_2, i) - big_value) < 0) {
            big_value = 1;
        } else {
            big_value = 0;
        }
    }
}

int positionFirstNum(s21_decimal d) {
    int i = 95;
    for (; getBit(d, i) != 1 && i >= 0; i--) {
    }
    return i;
}

void initDecimal(s21_decimal *d) {
    d->bits[0] = 0;
    d->bits[1] = 0;
    d->bits[2] = 0;
    d->bits[3] = 0;
}

void copyDecimalToDecimal(s21_decimal value_1, s21_decimal *value_2) {
    value_2->bits[0] = value_1.bits[0];
    value_2->bits[1] = value_1.bits[1];
    value_2->bits[2] = value_1.bits[2];
    value_2->bits[3] = value_1.bits[3];
}

int generetionTruncFloor(s21_decimal value, s21_decimal *result) {
    int Scale = getScale(value);
    if (shiftScaleRigth(&value, Scale) == 1) {
        s21_decimal value_2 = {{1, 0, 0, 0}};
        subBits(value, value_2, result);
    } else {
        copyDecimalToDecimal(value, result);
    }
    return 0;
}

unsigned int getFloatSign(float src) { return (unsigned int)src >> 31; }

char getScaleFloat(float *src) {
    return (char)((*(unsigned int *)src >> 23) - 127);
}

void getBinaryFromFloatTest(float src, char *float_bin_buff) {
    unsigned int buf = *((unsigned int *)&src);
    for (unsigned int mask = 0x80000000; mask; mask >>= 1) {
        *float_bin_buff = !!(buf & mask);
        float_bin_buff++;
    }
}